// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package api

import (
	"context"
	"encoding/json"
	"net/http"
	"time"
	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-playground/validator/v10"
	"github.com/jolfzverb/codegen/internal/usage/generated/api/models"
)

type PostPathToParamResourseJSONHandler interface {
	HandlePostPathToParamResourseJSON(ctx context.Context, r *models.PostPathToParamResourseJSONRequest) (*models.PostPathToParamResourseJSONResponse, error)
}
type Handler struct {
	validator                   *validator.Validate
	postPathToParamResourseJSON PostPathToParamResourseJSONHandler
}

func NewHandler(postPathToParamResourseJSON PostPathToParamResourseJSONHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), postPathToParamResourseJSON: postPathToParamResourseJSON}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Post("/path/to/{param}/resourse", h.handlePostPathToParamResourse)
}
func (h *Handler) parsePostPathToParamResourseJSONPathParams(r *http.Request) (*models.PostPathToParamResourseJSONPathParams, error) {
	var pathParams models.PostPathToParamResourseJSONPathParams
	param := chi.URLParam(r, "param")
	if param == "" {
		return nil, errors.New("param path param is required")
	}
	pathParams.Param = &param
	return &pathParams, nil
}
func (h *Handler) parsePostPathToParamResourseJSONQueryParams(r *http.Request) (*models.PostPathToParamResourseJSONQueryParams, error) {
	var queryParams models.PostPathToParamResourseJSONQueryParams
	count := r.URL.Query().Get("count")
	if count == "" {
		return nil, errors.New("count query param is required")
	}
	queryParams.Count = &count
	return &queryParams, nil
}
func (h *Handler) parsePostPathToParamResourseJSONHeaders(r *http.Request) (*models.PostPathToParamResourseJSONHeaders, error) {
	var headers models.PostPathToParamResourseJSONHeaders
	idempotencyKey := r.Header.Get("Idempotency-Key")
	if idempotencyKey == "" {
		return nil, errors.New("Idempotency-Key header is required")
	}
	headers.IdempotencyKey = &idempotencyKey
	optionalHeader := r.Header.Get("Optional-Header")
	if optionalHeader != "" {
		parsedOptionalHeader, err := time.Parse(time.RFC3339, optionalHeader)
		if err != nil {
			return nil, errors.Wrap(err, "OptionalHeader is not a valid date-time format")
		}
		headers.OptionalHeader = &parsedOptionalHeader
	}
	return &headers, nil
}
func (h *Handler) parsePostPathToParamResourseJSONRequestBody(r *http.Request) (*models.PostPathToParamResourseJSONRequestBody, error) {
	var body models.PostPathToParamResourseJSONRequestBody
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		return nil, err
	}
	err = h.validator.Struct(body)
	if err != nil {
		return nil, err
	}
	return &body, nil
}
func (h *Handler) parsePostPathToParamResourseJSONRequest(r *http.Request) (*models.PostPathToParamResourseJSONRequest, error) {
	pathParams, err := h.parsePostPathToParamResourseJSONPathParams(r)
	if err != nil {
		return nil, err
	}
	queryParams, err := h.parsePostPathToParamResourseJSONQueryParams(r)
	if err != nil {
		return nil, err
	}
	headers, err := h.parsePostPathToParamResourseJSONHeaders(r)
	if err != nil {
		return nil, err
	}
	body, err := h.parsePostPathToParamResourseJSONRequestBody(r)
	if err != nil {
		return nil, err
	}
	return &models.PostPathToParamResourseJSONRequest{Path: *pathParams, Query: *queryParams, Headers: *headers, Body: *body}, nil
}
func (h *Handler) writePostPathToParamResourseJSON200Response(w http.ResponseWriter, r *models.PostPathToParamResourseJSONResponse200) {
	var err error
	headersJSON, err := json.Marshal(r.Headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	var headers map[string]string
	err = json.Unmarshal(headersJSON, &headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	for key, value := range headers {
		w.Header().Set(key, value)
	}
	err = json.NewEncoder(w).Encode(r.Body)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
}
func (h *Handler) writePostPathToParamResourseJSON400Response(w http.ResponseWriter, r *models.PostPathToParamResourseJSONResponse400) {
}
func (h *Handler) writePostPathToParamResourseJSON404Response(w http.ResponseWriter, r *models.PostPathToParamResourseJSONResponse404) {
}
func (h *Handler) writePostPathToParamResourseJSONResponse(w http.ResponseWriter, response *models.PostPathToParamResourseJSONResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writePostPathToParamResourseJSON200Response(w, response.Response200)
	case 400:
		if response.Response400 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writePostPathToParamResourseJSON400Response(w, response.Response400)
	case 404:
		if response.Response404 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writePostPathToParamResourseJSON404Response(w, response.Response404)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handlePostPathToParamResourseJSON(w http.ResponseWriter, r *http.Request) {
	request, err := h.parsePostPathToParamResourseJSONRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.postPathToParamResourseJSON.HandlePostPathToParamResourseJSON(ctx, request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writePostPathToParamResourseJSONResponse(w, response)
	return
}
func (h *Handler) handlePostPathToParamResourse(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handlePostPathToParamResourseJSON(w, r)
		return
	case "":
		h.handlePostPathToParamResourseJSON(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
