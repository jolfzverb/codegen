// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package api

import (
	"context"
	"encoding/json"
	"net/http"
	"time"
	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-playground/validator/v10"
	"github.com/jolfzverb/codegen/internal/usage/generated/api/models"
)

type CreateJSONHandler interface {
	HandleCreateJSON(ctx context.Context, r *models.CreateJSONRequest) (*models.CreateJSONResponse, error)
}
type Handler struct {
	validator  *validator.Validate
	createJSON CreateJSONHandler
}

func NewHandler(createJSON CreateJSONHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), createJSON: createJSON}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Post("/path/to/{param}/resourse", h.handleCreate)
}
func (h *Handler) parseCreateJSONPathParams(r *http.Request) (*models.CreateJSONPathParams, error) {
	var pathParams models.CreateJSONPathParams
	param := chi.URLParam(r, "param")
	if param == "" {
		return nil, errors.New("param path param is required")
	}
	pathParams.Param = &param
	return &pathParams, nil
}
func (h *Handler) parseCreateJSONQueryParams(r *http.Request) (*models.CreateJSONQueryParams, error) {
	var queryParams models.CreateJSONQueryParams
	count := r.URL.Query().Get("count")
	if count == "" {
		return nil, errors.New("count query param is required")
	}
	queryParams.Count = &count
	return &queryParams, nil
}
func (h *Handler) parseCreateJSONHeaders(r *http.Request) (*models.CreateJSONHeaders, error) {
	var headers models.CreateJSONHeaders
	idempotencyKey := r.Header.Get("Idempotency-Key")
	if idempotencyKey == "" {
		return nil, errors.New("Idempotency-Key header is required")
	}
	headers.IdempotencyKey = &idempotencyKey
	optionalHeader := r.Header.Get("Optional-Header")
	if optionalHeader != "" {
		parsedOptionalHeader, err := time.Parse(time.RFC3339, optionalHeader)
		if err != nil {
			return nil, errors.Wrap(err, "OptionalHeader is not a valid date-time format")
		}
		headers.OptionalHeader = &parsedOptionalHeader
	}
	return &headers, nil
}
func (h *Handler) parseCreateJSONRequestBody(r *http.Request) (*models.CreateJSONRequestBody, error) {
	var body models.CreateJSONRequestBody
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		return nil, err
	}
	err = h.validator.Struct(body)
	if err != nil {
		return nil, err
	}
	return &body, nil
}
func (h *Handler) parseCreateJSONRequest(r *http.Request) (*models.CreateJSONRequest, error) {
	pathParams, err := h.parseCreateJSONPathParams(r)
	if err != nil {
		return nil, err
	}
	queryParams, err := h.parseCreateJSONQueryParams(r)
	if err != nil {
		return nil, err
	}
	headers, err := h.parseCreateJSONHeaders(r)
	if err != nil {
		return nil, err
	}
	body, err := h.parseCreateJSONRequestBody(r)
	if err != nil {
		return nil, err
	}
	return &models.CreateJSONRequest{Path: *pathParams, Query: *queryParams, Headers: *headers, Body: *body}, nil
}
func (h *Handler) writeCreateJSON200Response(w http.ResponseWriter, r *models.CreateJSONResponse200) {
	var err error
	headersJSON, err := json.Marshal(r.Headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	var headers map[string]string
	err = json.Unmarshal(headersJSON, &headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	for key, value := range headers {
		w.Header().Set(key, value)
	}
	err = json.NewEncoder(w).Encode(r.Body)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
}
func (h *Handler) writeCreateJSON400Response(w http.ResponseWriter, r *models.CreateJSONResponse400) {
}
func (h *Handler) writeCreateJSON404Response(w http.ResponseWriter, r *models.CreateJSONResponse404) {
}
func (h *Handler) writeCreateJSONResponse(w http.ResponseWriter, response *models.CreateJSONResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeCreateJSON200Response(w, response.Response200)
	case 400:
		if response.Response400 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeCreateJSON400Response(w, response.Response400)
	case 404:
		if response.Response404 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeCreateJSON404Response(w, response.Response404)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handleCreateJSON(w http.ResponseWriter, r *http.Request) {
	request, err := h.parseCreateJSONRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.createJSON.HandleCreateJSON(ctx, request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writeCreateJSONResponse(w, response)
	return
}
func (h *Handler) handleCreate(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handleCreateJSON(w, r)
		return
	case "":
		h.handleCreateJSON(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
