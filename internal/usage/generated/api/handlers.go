// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package api

import (
	"context"
	"encoding/json"
	"net/http"
	"time"
	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-playground/validator/v10"
	"github.com/jolfzverb/codegen/internal/usage/generated/api/models"
)

type CreateHandler interface {
	HandleCreate(ctx context.Context, r *models.CreateRequest) (*models.CreateResponse, error)
}
type Handler struct {
	validator *validator.Validate
	create    CreateHandler
}

func NewHandler(create CreateHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), create: create}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Post("/path/to/{param}/resourse", h.handleCreate)
}
func (h *Handler) parseCreatePathParams(r *http.Request) (*models.CreatePathParams, error) {
	var pathParams models.CreatePathParams
	param := chi.URLParam(r, "param")
	if param == "" {
		return nil, errors.New("param path param is required")
	}
	pathParams.Param = param
	err := h.validator.Struct(pathParams)
	if err != nil {
		return nil, err
	}
	return &pathParams, nil
}
func (h *Handler) parseCreateQueryParams(r *http.Request) (*models.CreateQueryParams, error) {
	var queryParams models.CreateQueryParams
	count := r.URL.Query().Get("count")
	if count == "" {
		return nil, errors.New("count query param is required")
	}
	queryParams.Count = count
	err := h.validator.Struct(queryParams)
	if err != nil {
		return nil, err
	}
	return &queryParams, nil
}
func (h *Handler) parseCreateHeaders(r *http.Request) (*models.CreateHeaders, error) {
	var headers models.CreateHeaders
	idempotencyKey := r.Header.Get("Idempotency-Key")
	if idempotencyKey == "" {
		return nil, errors.New("Idempotency-Key header is required")
	}
	headers.IdempotencyKey = idempotencyKey
	optionalHeader := r.Header.Get("Optional-Header")
	if optionalHeader != "" {
		parsedOptionalHeader, err := time.Parse(time.RFC3339, optionalHeader)
		if err != nil {
			return nil, errors.Wrap(err, "OptionalHeader is not a valid date-time format")
		}
		headers.OptionalHeader = &parsedOptionalHeader
	}
	err := h.validator.Struct(headers)
	if err != nil {
		return nil, err
	}
	return &headers, nil
}
func (h *Handler) parseCreateRequestBody(r *http.Request) (*models.CreateRequestBody, error) {
	var body models.CreateRequestBody
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		return nil, err
	}
	err = h.validator.Struct(body)
	if err != nil {
		return nil, err
	}
	return &body, nil
}
func (h *Handler) parseCreateRequest(r *http.Request) (*models.CreateRequest, error) {
	pathParams, err := h.parseCreatePathParams(r)
	if err != nil {
		return nil, err
	}
	queryParams, err := h.parseCreateQueryParams(r)
	if err != nil {
		return nil, err
	}
	headers, err := h.parseCreateHeaders(r)
	if err != nil {
		return nil, err
	}
	body, err := h.parseCreateRequestBody(r)
	if err != nil {
		return nil, err
	}
	return &models.CreateRequest{Path: *pathParams, Query: *queryParams, Headers: *headers, Body: *body}, nil
}
func Create200Response(body models.NewResourseResponse, headers models.CreateResponse200Headers) *models.CreateResponse {
	return &models.CreateResponse{StatusCode: 200, Response200: &models.CreateResponse200{Body: body, Headers: headers}}
}
func (h *Handler) writeCreate200Response(w http.ResponseWriter, r *models.CreateResponse200) {
	var err error
	headersJSON, err := json.Marshal(r.Headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	var headers map[string]string
	err = json.Unmarshal(headersJSON, &headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	for key, value := range headers {
		w.Header().Set(key, value)
	}
	err = json.NewEncoder(w).Encode(r.Body)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
}
func Create400Response() *models.CreateResponse {
	return &models.CreateResponse{StatusCode: 400, Response400: &models.CreateResponse400{}}
}
func (h *Handler) writeCreate400Response(w http.ResponseWriter, r *models.CreateResponse400) {
}
func Create404Response() *models.CreateResponse {
	return &models.CreateResponse{StatusCode: 404, Response404: &models.CreateResponse404{}}
}
func (h *Handler) writeCreate404Response(w http.ResponseWriter, r *models.CreateResponse404) {
}
func (h *Handler) writeCreateResponse(w http.ResponseWriter, response *models.CreateResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeCreate200Response(w, response.Response200)
	case 400:
		if response.Response400 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeCreate400Response(w, response.Response400)
	case 404:
		if response.Response404 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeCreate404Response(w, response.Response404)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handleCreateRequest(w http.ResponseWriter, r *http.Request) {
	request, err := h.parseCreateRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.create.HandleCreate(ctx, request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writeCreateResponse(w, response)
	return
}
func (h *Handler) handleCreate(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handleCreateRequest(w, r)
		return
	case "":
		h.handleCreateRequest(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
