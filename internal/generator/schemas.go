package generator

import (
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-faster/errors"
)

type SchemasFile struct {
	file *ast.File
}

type SchemaStruct struct {
	Name   string
	Fields []SchemaField
}

type SchemaField struct {
	Name        string
	Type        string
	TagJSON     []string
	TagValidate []string
	Required    bool
}

func NewSchemasFile() *SchemasFile {
	return &SchemasFile{
		file: &ast.File{
			Name:    ast.NewIdent("models"),
			Imports: []*ast.ImportSpec{},
			Decls:   []ast.Decl{},
		},
	}
}

func (m *SchemasFile) WriteToOutput(output io.Writer) error {
	const op = "generator.SchemasFile.WriteToOutput"
	// go/ast package is great!
	_, err := output.Write([]byte("// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.\n\n"))
	if err != nil {
		return errors.Wrap(err, op)
	}

	err = format.Node(output, token.NewFileSet(), m.file)
	if err != nil {
		return errors.Wrap(err, op)
	}

	return nil
}

func (m *SchemasFile) AddSchema(model SchemaStruct) {
	fieldList := make([]*ast.Field, 0, len(model.Fields))
	for _, field := range model.Fields {
		jsonTags := strings.Join(field.TagJSON, ",")
		validateTags := strings.Join(field.TagValidate, ",")

		var tags string
		if len(field.TagJSON) > 0 {
			tags += "json:\"" + jsonTags + "\""
		}
		if len(field.TagValidate) > 0 {
			if len(tags) > 0 {
				tags += " "
			}
			tags += "validate:\"" + validateTags + "\""
		}
		if len(tags) > 0 {
			tags = "`" + tags + "`"
		}
		var typeExpr ast.Expr
		if field.Required {
			typeExpr = ast.NewIdent(field.Type)
		} else {
			typeExpr = &ast.StarExpr{
				Star: token.NoPos,
				X:    ast.NewIdent(field.Type),
			}
		}
		var tag *ast.BasicLit
		if len(tags) > 0 {
			tag = &ast.BasicLit{
				Kind:  token.STRING,
				Value: tags,
			}
		}
		fieldList = append(fieldList, &ast.Field{
			Names: []*ast.Ident{ast.NewIdent(field.Name)},
			Type:  typeExpr,
			Tag:   tag,
		})
	}

	m.file.Decls = append(m.file.Decls, &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(model.Name),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: fieldList,
					},
				},
			},
		},
	})
}

func (m *SchemasFile) AddTypeAlias(name string, typeName string) {
	m.file.Decls = append(m.file.Decls, &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(name),
				Type: &ast.Ident{
					Name: typeName,
				},
			},
		},
	})
}

func (m *SchemasFile) AddSliceAlias(name string, typeName string) {
	m.file.Decls = append(m.file.Decls, &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(name),
				Type: &ast.ArrayType{
					Elt: ast.NewIdent(typeName),
				},
			},
		},
	})
}

func (m *SchemasFile) AddParamsModel(baseName string, paramType string, params openapi3.Parameters) error {
	fields := make([]SchemaField, 0, len(params))
	for _, param := range params {
		if !param.Value.Schema.Value.Type.Permits(openapi3.TypeString) {
			return errors.New("only string type parameters are supported for " + paramType + " parameters")
		}
		field := SchemaField{
			Name:    FormatGoLikeIdentifier(param.Value.Name),
			Type:    "string",
			TagJSON: []string{param.Value.Name},
		}
		if param.Value.Required {
			field.TagValidate = append(field.TagValidate, "required")
		}
		fields = append(fields, field)
	}

	model := SchemaStruct{
		Name:   baseName + paramType,
		Fields: fields,
	}
	m.AddSchema(model)

	return nil
}

func (m *SchemasFile) AddHeadersModel(baseName string, headers openapi3.Headers) error {
	fields := make([]SchemaField, 0, len(headers))
	for name, header := range headers {
		if !header.Value.Schema.Value.Type.Permits(openapi3.TypeString) {
			return errors.New("only string type parameters are supported for response headers")
		}
		field := SchemaField{
			Name:    FormatGoLikeIdentifier(name),
			Type:    "string",
			TagJSON: []string{name},
		}
		if header.Value.Required {
			field.TagValidate = append(field.TagValidate, "required")
		}
		fields = append(fields, field)
	}

	model := SchemaStruct{
		Name:   baseName + "Headers",
		Fields: fields,
	}
	m.AddSchema(model)

	return nil
}
