package generator_test

import (
	"bytes"
	"context"
	"strings"
	"testing"

	"github.com/jolfzverb/codegen/internal/generator"
	"github.com/jolfzverb/codegen/internal/generator/options"
	"github.com/stretchr/testify/assert"
)

func TestGenerateValidInput(t *testing.T) {
	mockInput := `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ExampleModel:
      type: object
      properties:
        field_two:
          type: integer
        field_one:
          type: string
          minLength: 3
          maxLength: 10
        field_three:
          $ref: '#/components/schemas/StringModel'
        field4:
          type: object
          properties:
            field1:
              type: string
        field5:
          $ref: '#/components/schemas/ObjectModel'
        field6:
          type: number
          minimum: 1.5
          maximum: 10.5
      required:
        - field_one
        - field6
    StringModel:
      type: string
    IntModel:
      type: integer
    ObjectModel:
      type: object
      properties:
        field1:
          type: string
`

	expectedOutput := `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ExampleModelField4 struct {
	Field1 *string ` + "`json:\"field1,omitempty\" validate:\"omitempty\"`" + `
}
type ExampleModel struct {
	Field4     *ExampleModelField4 ` + "`json:\"field4,omitempty\" validate:\"omitempty\"`" + `
	Field5     *ObjectModel        ` + "`json:\"field5,omitempty\" validate:\"omitempty\"`" + `
	Field6     float64             ` + "`json:\"field6\" validate:\"required,min=1.5,max=10.5\"`" + `
	FieldOne   string              ` + "`json:\"field_one\" validate:\"required,min=3,max=10\"`" + `
	FieldThree *StringModel        ` + "`json:\"field_three,omitempty\" validate:\"omitempty\"`" + `
	FieldTwo   *int                ` + "`json:\"field_two,omitempty\" validate:\"omitempty\"`" + `
}
type IntModel int
type ObjectModel struct {
	Field1 *string ` + "`json:\"field1,omitempty\" validate:\"omitempty\"`" + `
}
type StringModel string
`

	input := strings.NewReader(mockInput)
	outputModels := &bytes.Buffer{}
	outputHandlers := &bytes.Buffer{}

	err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename", &options.Options{})

	assert.NoError(t, err)

	assert.Equal(t, expectedOutput, outputModels.String())
}

func TestGeneratorFeatures(t *testing.T) {
	for _, tc := range []struct {
		name     string
		input    string
		expected string
	}{
		{
			name: "TestString",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    StringModel:
      type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type StringModel string
`,
		},
		{
			name: "TestInt",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    IntModel:
      type: integer
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type IntModel int
`,
		},
		{
			name: "TestNumber",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    NumberModel:
      type: number
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type NumberModel float64
`,
		},
		{
			name: "TestBool",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    BoolModel:
      type: boolean
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type BoolModel bool
`,
		},
		{
			name: "TestSimpleObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestEmptyObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
}
`,
		},
		{
			name: "TestStringValidatorsObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
          minLength: 3
          maxLength: 10
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty,min=3,max=10\"`" + `
}
`,
		},
		{
			name: "TestStringReferenceObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    StringModel:
      type: string
      minLength: 3
      maxLength: 10
    ObjectModel:
      type: object
      properties:
        string_field:
          $ref: '#/components/schemas/StringModel'
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	StringField *StringModel ` + "`json:\"string_field,omitempty\" validate:\"omitempty,min=3,max=10\"`" + `
}
type StringModel string
`,
		},
		{
			name: "TestFieldTypesInObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
        int_field:
          type: integer
        number_field:
          type: number
        bool_field:
          type: boolean
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	BoolField   *bool    ` + "`json:\"bool_field,omitempty\" validate:\"omitempty\"`" + `
	IntField    *int     ` + "`json:\"int_field,omitempty\" validate:\"omitempty\"`" + `
	NumberField *float64 ` + "`json:\"number_field,omitempty\" validate:\"omitempty\"`" + `
	StringField *string  ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestObjectRef",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        object_field:
          $ref: '#/components/schemas/Object2Model'
    Object2Model:
      type: object
      properties:
        string_field:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type Object2Model struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ObjectModel struct {
	ObjectField *Object2Model ` + "`json:\"object_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestNestedObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        object_field:
          type: object
          properties:
            string_field:
              type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModelObjectField struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ObjectModel struct {
	ObjectField *ObjectModelObjectField ` + "`json:\"object_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestArrayStringRefSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        $ref: '#/components/schemas/StringModel'
    StringModel:
      type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []StringModel
type StringModel string
`,
		},
		{
			name: "TestArrayObjectRefSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        $ref: '#/components/schemas/ObjectModel'
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []ObjectModel
type ObjectModel struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestArrayStringSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []string
`,
		},
		{
			name: "TestArrayBoolSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: boolean
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []bool
`,
		},
		{
			name: "TestArrayIntSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: integer
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []int
`,
		},
		{
			name: "TestArrayNumberSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: number
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []float64
`,
		},
		{
			name: "TestArrayObjectSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: object
        properties:
          string_field:
            type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModelItem struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ArrayModel []ArrayModelItem
`,
		},
		{
			name: "TestArrayNestedObjectSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: object
        properties:
          object_field:
            type: object
            properties:
              string_field:
                type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModelItemObjectField struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ArrayModelItem struct {
	ObjectField *ArrayModelItemObjectField ` + "`json:\"object_field,omitempty\" validate:\"omitempty\"`" + `
}
type ArrayModel []ArrayModelItem
`,
		},
		{
			name: "TestArrayNestedArrayRefSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        $ref: '#/components/schemas/Array2Model'
    Array2Model:
      type: array
      items:
        type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type Array2Model []string
type ArrayModel []Array2Model
`,
		},
		{
			name: "TestArrayNestedArraySchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: array
        items:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModelItem []string
type ArrayModel []ArrayModelItem
`,
		},
		{
			name: "TestObjectRefArraySchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: string
    ObjectModel:
      type: object
      properties:
        array_field:
          $ref: '#/components/schemas/ArrayModel'
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []string
type ObjectModel struct {
	ArrayField *ArrayModel ` + "`json:\"array_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestObjectArraySchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        array_field:
          type: array
          items:
            type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModelArrayField []string
type ObjectModel struct {
	ArrayField *ObjectModelArrayField ` + "`json:\"array_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestObjectArrayValidatorsSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        array_field:
          type: array
          minItems: 1
          maxItems: 10
          uniqueItems: true
          items:
            type: string
            minLength: 3
            maxLength: 10
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModelArrayField []string
type ObjectModel struct {
	ArrayField *ObjectModelArrayField ` + "`json:\"array_field,omitempty\" validate:\"omitempty,min=1,max=10,unique,dive,min=3,max=10\"`" + `
}
`,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			outputModels := &bytes.Buffer{}
			outputHandlers := &bytes.Buffer{}

			err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename", &options.Options{})

			assert.NoError(t, err)
			assert.Equal(t, tc.expected, outputModels.String())
		})
	}
}

func TestGeneratePaths(t *testing.T) {
	for _, tc := range []struct {
		name             string
		input            string
		expectedModels   string
		expectedHandlers string
	}{
		{
			name: "TestString",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths:
  /example/{param_name}:
    post:
      summary: Example
      parameters:
        - name: param_name
          in: path
          required: true
          schema:
            type: string
        - name: param_name2
          in: query
          required: true
          schema:
            type: string
        - name: X-Header
          in: header
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                code:
                  type: string
              required:
                - code
      responses:
        '200':
          description: OK
          headers:
            X-Header:
              description: X-Header
              schema:
                type: string
              required: true
  /example2:
    get:
      summary: Example
      responses:
        '200':
          description: OK
`,
			expectedModels: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type GetExample2Request struct {
}
type GetExample2Response200 struct {
}
type GetExample2Response struct {
	StatusCode  int
	Response200 *GetExample2Response200
}
type PostExampleParamNamePathParams struct {
	ParamName string ` + "`json:\"param_name\" validate:\"required\"`" + `
}
type PostExampleParamNameQueryParams struct {
	ParamName2 string ` + "`json:\"param_name2\" validate:\"required\"`" + `
}
type PostExampleParamNameHeaders struct {
	XHeader string ` + "`json:\"X-Header\" validate:\"required\"`" + `
}
type PostExampleParamNameRequestBody struct {
	Code string ` + "`json:\"code\" validate:\"required\"`" + `
}
type PostExampleParamNameRequest struct {
	Path    PostExampleParamNamePathParams
	Query   PostExampleParamNameQueryParams
	Headers PostExampleParamNameHeaders
	Body    PostExampleParamNameRequestBody
}
type PostExampleParamNameResponse200Headers struct {
	XHeader string ` + "`json:\"X-Header\" validate:\"required\"`" + `
}
type PostExampleParamNameResponse200 struct {
	Headers PostExampleParamNameResponse200Headers
}
type PostExampleParamNameResponse struct {
	StatusCode  int
	Response200 *PostExampleParamNameResponse200
}
`,
			expectedHandlers: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package packagename

import (
	"context"
	"encoding/json"
	"net/http"
	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-playground/validator/v10"
	"imports/models"
)

type GetExample2Handler interface {
	HandleGetExample2(ctx context.Context, r models.GetExample2Request) (*models.GetExample2Response, error)
}
type PostExampleParamNameHandler interface {
	HandlePostExampleParamName(ctx context.Context, r models.PostExampleParamNameRequest) (*models.PostExampleParamNameResponse, error)
}
type Handler struct {
	validator            *validator.Validate
	getExample2          GetExample2Handler
	postExampleParamName PostExampleParamNameHandler
}

func NewHandler(getExample2 GetExample2Handler, postExampleParamName PostExampleParamNameHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), getExample2: getExample2, postExampleParamName: postExampleParamName}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Get("/example2", h.handleGetExample2)
	router.Post("/example/{param_name}", h.handlePostExampleParamName)
}
func (h *Handler) parseGetExample2Request(r *http.Request) (*models.GetExample2Request, error) {
	return &models.GetExample2Request{}, nil
}
func GetExample2200Response() *models.GetExample2Response {
	return &models.GetExample2Response{StatusCode: 200, Response200: &models.GetExample2Response200{}}
}
func (h *Handler) writeGetExample2200Response(w http.ResponseWriter, r *models.GetExample2Response200) {
}
func (h *Handler) writeGetExample2Response(w http.ResponseWriter, response *models.GetExample2Response) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeGetExample2200Response(w, response.Response200)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handleGetExample2Request(w http.ResponseWriter, r *http.Request) {
	request, err := h.parseGetExample2Request(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.getExample2.HandleGetExample2(ctx, *request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writeGetExample2Response(w, response)
	return
}
func (h *Handler) handleGetExample2(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handleGetExample2Request(w, r)
		return
	case "":
		h.handleGetExample2Request(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
func (h *Handler) parsePostExampleParamNamePathParams(r *http.Request) (*models.PostExampleParamNamePathParams, error) {
	var pathParams models.PostExampleParamNamePathParams
	paramName := chi.URLParam(r, "param_name")
	if paramName == "" {
		return nil, errors.New("param_name path param is required")
	}
	pathParams.ParamName = paramName
	err := h.validator.Struct(pathParams)
	if err != nil {
		return nil, err
	}
	return &pathParams, nil
}
func (h *Handler) parsePostExampleParamNameQueryParams(r *http.Request) (*models.PostExampleParamNameQueryParams, error) {
	var queryParams models.PostExampleParamNameQueryParams
	paramName2 := r.URL.Query().Get("param_name2")
	if paramName2 == "" {
		return nil, errors.New("param_name2 query param is required")
	}
	queryParams.ParamName2 = paramName2
	err := h.validator.Struct(queryParams)
	if err != nil {
		return nil, err
	}
	return &queryParams, nil
}
func (h *Handler) parsePostExampleParamNameHeaders(r *http.Request) (*models.PostExampleParamNameHeaders, error) {
	var headers models.PostExampleParamNameHeaders
	xHeader := r.Header.Get("X-Header")
	if xHeader == "" {
		return nil, errors.New("X-Header header is required")
	}
	headers.XHeader = xHeader
	err := h.validator.Struct(headers)
	if err != nil {
		return nil, err
	}
	return &headers, nil
}
func (h *Handler) parsePostExampleParamNameRequestBody(r *http.Request) (*models.PostExampleParamNameRequestBody, error) {
	var body models.PostExampleParamNameRequestBody
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		return nil, err
	}
	err = h.validator.Struct(body)
	if err != nil {
		return nil, err
	}
	return &body, nil
}
func (h *Handler) parsePostExampleParamNameRequest(r *http.Request) (*models.PostExampleParamNameRequest, error) {
	pathParams, err := h.parsePostExampleParamNamePathParams(r)
	if err != nil {
		return nil, err
	}
	queryParams, err := h.parsePostExampleParamNameQueryParams(r)
	if err != nil {
		return nil, err
	}
	headers, err := h.parsePostExampleParamNameHeaders(r)
	if err != nil {
		return nil, err
	}
	body, err := h.parsePostExampleParamNameRequestBody(r)
	if err != nil {
		return nil, err
	}
	return &models.PostExampleParamNameRequest{Path: *pathParams, Query: *queryParams, Headers: *headers, Body: *body}, nil
}
func PostExampleParamName200Response(headers models.PostExampleParamNameResponse200Headers) *models.PostExampleParamNameResponse {
	return &models.PostExampleParamNameResponse{StatusCode: 200, Response200: &models.PostExampleParamNameResponse200{Headers: headers}}
}
func (h *Handler) writePostExampleParamName200Response(w http.ResponseWriter, r *models.PostExampleParamNameResponse200) {
	var err error
	headersJSON, err := json.Marshal(r.Headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	var headers map[string]string
	err = json.Unmarshal(headersJSON, &headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	for key, value := range headers {
		w.Header().Set(key, value)
	}
}
func (h *Handler) writePostExampleParamNameResponse(w http.ResponseWriter, response *models.PostExampleParamNameResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writePostExampleParamName200Response(w, response.Response200)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handlePostExampleParamNameRequest(w http.ResponseWriter, r *http.Request) {
	request, err := h.parsePostExampleParamNameRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.postExampleParamName.HandlePostExampleParamName(ctx, *request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writePostExampleParamNameResponse(w, response)
	return
}
func (h *Handler) handlePostExampleParamName(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handlePostExampleParamNameRequest(w, r)
		return
	case "":
		h.handlePostExampleParamNameRequest(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
`,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			outputModels := &bytes.Buffer{}
			outputHandlers := &bytes.Buffer{}

			err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename", &options.Options{})

			assert.NoError(t, err)
			assert.Equal(t, tc.expectedModels, outputModels.String())
			assert.Equal(t, tc.expectedHandlers, outputHandlers.String())
		})
	}
}

func TestGenerateFeatures(t *testing.T) {
	for _, tc := range []struct {
		name             string
		input            string
		expectedModels   string
		expectedHandlers string
	}{
		{
			name: "body ref",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths:
  /example:
    post:
      summary: Example
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Body'
      responses:
        '200':
          description: OK
components:
  schemas:
    Body:
      type: object
      properties:
        message:
          type: string
`,
			expectedModels: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type Body struct {
	Message *string ` + "`json:\"message,omitempty\" validate:\"omitempty\"`" + `
}
type PostExampleRequest struct {
	Body Body
}
type PostExampleResponse200 struct {
}
type PostExampleResponse struct {
	StatusCode  int
	Response200 *PostExampleResponse200
}
`,
			expectedHandlers: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package packagename

import (
	"context"
	"net/http"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	"imports/models"
)

type PostExampleHandler interface {
	HandlePostExample(ctx context.Context, r models.PostExampleRequest) (*models.PostExampleResponse, error)
}
type Handler struct {
	validator   *validator.Validate
	postExample PostExampleHandler
}

func NewHandler(postExample PostExampleHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), postExample: postExample}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Post("/example", h.handlePostExample)
}
func (h *Handler) parsePostExampleRequestBody(r *http.Request) (*models.Body, error) {
	var body models.Body
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		return nil, err
	}
	err = h.validator.Struct(body)
	if err != nil {
		return nil, err
	}
	return &body, nil
}
func (h *Handler) parsePostExampleRequest(r *http.Request) (*models.PostExampleRequest, error) {
	body, err := h.parsePostExampleRequestBody(r)
	if err != nil {
		return nil, err
	}
	return &models.PostExampleRequest{Body: *body}, nil
}
func PostExample200Response() *models.PostExampleResponse {
	return &models.PostExampleResponse{StatusCode: 200, Response200: &models.PostExampleResponse200{}}
}
func (h *Handler) writePostExample200Response(w http.ResponseWriter, r *models.PostExampleResponse200) {
}
func (h *Handler) writePostExampleResponse(w http.ResponseWriter, response *models.PostExampleResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writePostExample200Response(w, response.Response200)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handlePostExampleRequest(w http.ResponseWriter, r *http.Request) {
	request, err := h.parsePostExampleRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.postExample.HandlePostExample(ctx, *request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writePostExampleResponse(w, response)
	return
}
func (h *Handler) handlePostExample(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handlePostExampleRequest(w, r)
		return
	case "":
		h.handlePostExampleRequest(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
`,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			outputModels := &bytes.Buffer{}
			outputHandlers := &bytes.Buffer{}

			err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename", &options.Options{})

			assert.NoError(t, err)
			assert.Equal(t, tc.expectedModels, outputModels.String())
			assert.Equal(t, tc.expectedHandlers, outputHandlers.String())
		})
	}
}

func TestGenerateFeatures2(t *testing.T) {
	for _, tc := range []struct {
		name             string
		input            string
		expectedModels   string
		expectedHandlers string
	}{
		{
			name: "operation id",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths:
  /example:
    post:
      operationId: op
      summary: Example
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Body'
      responses:
        '200':
          description: OK
components:
  schemas:
    Body:
      type: object
      properties:
        message:
          type: string
`,
			expectedModels: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type Body struct {
	Message *string ` + "`json:\"message,omitempty\" validate:\"omitempty\"`" + `
}
type OpRequest struct {
	Body Body
}
type OpResponse200 struct {
}
type OpResponse struct {
	StatusCode  int
	Response200 *OpResponse200
}
`,
			expectedHandlers: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package packagename

import (
	"context"
	"net/http"
	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"
	"imports/models"
)

type OpHandler interface {
	HandleOp(ctx context.Context, r models.OpRequest) (*models.OpResponse, error)
}
type Handler struct {
	validator *validator.Validate
	op        OpHandler
}

func NewHandler(op OpHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), op: op}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Post("/example", h.handleOp)
}
func (h *Handler) parseOpRequestBody(r *http.Request) (*models.Body, error) {
	var body models.Body
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		return nil, err
	}
	err = h.validator.Struct(body)
	if err != nil {
		return nil, err
	}
	return &body, nil
}
func (h *Handler) parseOpRequest(r *http.Request) (*models.OpRequest, error) {
	body, err := h.parseOpRequestBody(r)
	if err != nil {
		return nil, err
	}
	return &models.OpRequest{Body: *body}, nil
}
func Op200Response() *models.OpResponse {
	return &models.OpResponse{StatusCode: 200, Response200: &models.OpResponse200{}}
}
func (h *Handler) writeOp200Response(w http.ResponseWriter, r *models.OpResponse200) {
}
func (h *Handler) writeOpResponse(w http.ResponseWriter, response *models.OpResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeOp200Response(w, response.Response200)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handleOpRequest(w http.ResponseWriter, r *http.Request) {
	request, err := h.parseOpRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.op.HandleOp(ctx, *request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writeOpResponse(w, response)
	return
}
func (h *Handler) handleOp(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handleOpRequest(w, r)
		return
	case "":
		h.handleOpRequest(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
`,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			outputModels := &bytes.Buffer{}
			outputHandlers := &bytes.Buffer{}

			err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename", &options.Options{})

			assert.NoError(t, err)
			assert.Equal(t, tc.expectedModels, outputModels.String())
			assert.Equal(t, tc.expectedHandlers, outputHandlers.String())
		})
	}
}

func TestGenerateCookies(t *testing.T) {
	for _, tc := range []struct {
		name             string
		input            string
		expectedModels   string
		expectedHandlers string
	}{
		{
			name: "operation id",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths:
  /example:
    post:
      operationId: op
      summary: Example
      parameters:
        - name: cookie-field
          in: cookie
          schema:
            type: string
      responses:
        '200':
          description: OK
`,
			expectedModels: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type OpCookies struct {
	CookieField *string ` + "`json:\"cookie-field,omitempty\" validate:\"omitempty\"`" + `
}
type OpRequest struct {
	Cookies OpCookies
}
type OpResponse200 struct {
}
type OpResponse struct {
	StatusCode  int
	Response200 *OpResponse200
}
`,
			expectedHandlers: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package packagename

import (
	"context"
	"net/http"
	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-playground/validator/v10"
	"imports/models"
)

type OpHandler interface {
	HandleOp(ctx context.Context, r models.OpRequest) (*models.OpResponse, error)
}
type Handler struct {
	validator *validator.Validate
	op        OpHandler
}

func NewHandler(op OpHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), op: op}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Post("/example", h.handleOp)
}
func (h *Handler) parseOpCookies(r *http.Request) (*models.OpCookies, error) {
	var cookies models.OpCookies
	cookieField, err := r.Cookie("cookie-field")
	if err != nil && !errors.Is(err, http.ErrNoCookie) {
		return nil, err
	}
	if err == nil {
		cookieFieldValue := cookieField.Value
		cookies.CookieField = &cookieFieldValue
	}
	err = h.validator.Struct(cookies)
	if err != nil {
		return nil, err
	}
	return &cookies, nil
}
func (h *Handler) parseOpRequest(r *http.Request) (*models.OpRequest, error) {
	cookieParams, err := h.parseOpCookies(r)
	if err != nil {
		return nil, err
	}
	return &models.OpRequest{Cookies: *cookieParams}, nil
}
func Op200Response() *models.OpResponse {
	return &models.OpResponse{StatusCode: 200, Response200: &models.OpResponse200{}}
}
func (h *Handler) writeOp200Response(w http.ResponseWriter, r *models.OpResponse200) {
}
func (h *Handler) writeOpResponse(w http.ResponseWriter, response *models.OpResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeOp200Response(w, response.Response200)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handleOpRequest(w http.ResponseWriter, r *http.Request) {
	request, err := h.parseOpRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.op.HandleOp(ctx, *request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writeOpResponse(w, response)
	return
}
func (h *Handler) handleOp(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handleOpRequest(w, r)
		return
	case "":
		h.handleOpRequest(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
`,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			outputModels := &bytes.Buffer{}
			outputHandlers := &bytes.Buffer{}

			err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename", &options.Options{})

			assert.NoError(t, err)
			assert.Equal(t, tc.expectedModels, outputModels.String())
			assert.Equal(t, tc.expectedHandlers, outputHandlers.String())
		})
	}
}
