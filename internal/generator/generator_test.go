package generator_test

import (
	"bytes"
	"context"
	"strings"
	"testing"

	"github.com/jolfzverb/codegen/internal/generator"
	"github.com/stretchr/testify/assert"
)

func TestGenerateValidInput(t *testing.T) {
	mockInput := `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ExampleModel:
      type: object
      properties:
        field_two:
          type: integer
        field_one:
          type: string
          minLength: 3
          maxLength: 10
        field_three:
          $ref: '#/components/schemas/StringModel'
        field4:
          type: object
          properties:
            field1:
              type: string
        field5:
          $ref: '#/components/schemas/ObjectModel'
        field6:
          type: number
          minimum: 1.5
          maximum: 10.5
      required:
        - field_one
        - field6
    StringModel:
      type: string
    IntModel:
      type: integer
    ObjectModel:
      type: object
      properties:
        field1:
          type: string
`

	expectedOutput := `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ExampleModelField4 struct {
	Field1 *string ` + "`json:\"field1,omitempty\" validate:\"omitempty\"`" + `
}
type ExampleModel struct {
	Field4     *ExampleModelField4 ` + "`json:\"field4,omitempty\" validate:\"omitempty\"`" + `
	Field5     *ObjectModel        ` + "`json:\"field5,omitempty\" validate:\"omitempty\"`" + `
	Field6     *float64            ` + "`json:\"field6\" validate:\"required,min=1.5,max=10.5\"`" + `
	FieldOne   *string             ` + "`json:\"field_one\" validate:\"required,min=3,max=10\"`" + `
	FieldThree *StringModel        ` + "`json:\"field_three,omitempty\" validate:\"omitempty\"`" + `
	FieldTwo   *int                ` + "`json:\"field_two,omitempty\" validate:\"omitempty\"`" + `
}
type IntModel int
type ObjectModel struct {
	Field1 *string ` + "`json:\"field1,omitempty\" validate:\"omitempty\"`" + `
}
type StringModel string
`

	input := strings.NewReader(mockInput)
	outputModels := &bytes.Buffer{}
	outputHandlers := &bytes.Buffer{}

	err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename")

	assert.NoError(t, err)

	assert.Equal(t, expectedOutput, outputModels.String())
}

func TestGeneratorFeatures(t *testing.T) {
	for _, tc := range []struct {
		name     string
		input    string
		expected string
	}{
		{
			name: "TestString",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    StringModel:
      type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type StringModel string
`,
		},
		{
			name: "TestInt",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    IntModel:
      type: integer
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type IntModel int
`,
		},
		{
			name: "TestNumber",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    NumberModel:
      type: number
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type NumberModel float64
`,
		},
		{
			name: "TestBool",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    BoolModel:
      type: boolean
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type BoolModel bool
`,
		},
		{
			name: "TestSimpleObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestEmptyObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
}
`,
		},
		{
			name: "TestStringValidatorsObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
          minLength: 3
          maxLength: 10
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty,min=3,max=10\"`" + `
}
`,
		},
		{
			name: "TestStringReferenceObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    StringModel:
      type: string
      minLength: 3
      maxLength: 10
    ObjectModel:
      type: object
      properties:
        string_field:
          $ref: '#/components/schemas/StringModel'
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	StringField *StringModel ` + "`json:\"string_field,omitempty\" validate:\"omitempty,min=3,max=10\"`" + `
}
type StringModel string
`,
		},
		{
			name: "TestFieldTypesInObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
        int_field:
          type: integer
        number_field:
          type: number
        bool_field:
          type: boolean
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModel struct {
	BoolField   *bool    ` + "`json:\"bool_field,omitempty\" validate:\"omitempty\"`" + `
	IntField    *int     ` + "`json:\"int_field,omitempty\" validate:\"omitempty\"`" + `
	NumberField *float64 ` + "`json:\"number_field,omitempty\" validate:\"omitempty\"`" + `
	StringField *string  ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestObjectRef",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        object_field:
          $ref: '#/components/schemas/Object2Model'
    Object2Model:
      type: object
      properties:
        string_field:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type Object2Model struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ObjectModel struct {
	ObjectField *Object2Model ` + "`json:\"object_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestNestedObject",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        object_field:
          type: object
          properties:
            string_field:
              type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModelObjectField struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ObjectModel struct {
	ObjectField *ObjectModelObjectField ` + "`json:\"object_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestArrayStringRefSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        $ref: '#/components/schemas/StringModel'
    StringModel:
      type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []StringModel
type StringModel string
`,
		},
		{
			name: "TestArrayObjectRefSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        $ref: '#/components/schemas/ObjectModel'
    ObjectModel:
      type: object
      properties:
        string_field:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []ObjectModel
type ObjectModel struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestArrayStringSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []string
`,
		},
		{
			name: "TestArrayBoolSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: boolean
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []bool
`,
		},
		{
			name: "TestArrayIntSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: integer
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []int
`,
		},
		{
			name: "TestArrayNumberSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: number
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []float64
`,
		},
		{
			name: "TestArrayObjectSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: object
        properties:
          string_field:
            type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModelItem struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ArrayModel []ArrayModelItem
`,
		},
		{
			name: "TestArrayNestedObjectSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: object
        properties:
          object_field:
            type: object
            properties:
              string_field:
                type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModelItemObjectField struct {
	StringField *string ` + "`json:\"string_field,omitempty\" validate:\"omitempty\"`" + `
}
type ArrayModelItem struct {
	ObjectField *ArrayModelItemObjectField ` + "`json:\"object_field,omitempty\" validate:\"omitempty\"`" + `
}
type ArrayModel []ArrayModelItem
`,
		},
		{
			name: "TestArrayNestedArrayRefSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        $ref: '#/components/schemas/Array2Model'
    Array2Model:
      type: array
      items:
        type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type Array2Model []string
type ArrayModel []Array2Model
`,
		},
		{
			name: "TestArrayNestedArraySchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: array
        items:
          type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModelItem []string
type ArrayModel []ArrayModelItem
`,
		},
		{
			name: "TestObjectRefArraySchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ArrayModel:
      type: array
      items:
        type: string
    ObjectModel:
      type: object
      properties:
        array_field:
          $ref: '#/components/schemas/ArrayModel'
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ArrayModel []string
type ObjectModel struct {
	ArrayField *ArrayModel ` + "`json:\"array_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestObjectArraySchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        array_field:
          type: array
          items:
            type: string
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModelArrayField []string
type ObjectModel struct {
	ArrayField *ObjectModelArrayField ` + "`json:\"array_field,omitempty\" validate:\"omitempty\"`" + `
}
`,
		},
		{
			name: "TestObjectArrayValidatorsSchema",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths: {}
components:
  schemas:
    ObjectModel:
      type: object
      properties:
        array_field:
          type: array
          minItems: 1
          maxItems: 10
          uniqueItems: true
          items:
            type: string
            minLength: 3
            maxLength: 10
`,
			expected: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type ObjectModelArrayField []string
type ObjectModel struct {
	ArrayField *ObjectModelArrayField ` + "`json:\"array_field,omitempty\" validate:\"omitempty,min=1,max=10,unique,dive,min=3,max=10\"`" + `
}
`,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			outputModels := &bytes.Buffer{}
			outputHandlers := &bytes.Buffer{}

			err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename")

			assert.NoError(t, err)
			assert.Equal(t, tc.expected, outputModels.String())
		})
	}
}

func TestGeneratePaths(t *testing.T) {
	for _, tc := range []struct {
		name             string
		input            string
		expectedModels   string
		expectedHandlers string
	}{
		{
			name: "TestString",
			input: `openapi: 3.0.0
info:
  title: API
  version: 1.0.0
paths:
  /example/{param_name}:
    post:
      summary: Example
      parameters:
        - name: param_name
          in: path
          required: true
          schema:
            type: string
        - name: param_name2
          in: query
          required: true
          schema:
            type: string
        - name: X-Header
          in: header
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                code:
                  type: string
              required:
                - code
      responses:
        '200':
          description: OK
          headers:
            X-Header:
              description: X-Header
              schema:
                type: string
              required: true
  /example2:
    get:
      summary: Example
      responses:
        '200':
          description: OK
`,
			expectedModels: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package models

type GetExample2JSONRequest struct {
}
type GetExample2JSONResponse200 struct {
}
type GetExample2JSONResponse struct {
	StatusCode  int
	Response200 *GetExample2JSONResponse200
}
type PostExampleParamNameJSONPathParams struct {
	ParamName *string ` + "`json:\"param_name\" validate:\"required\"`" + `
}
type PostExampleParamNameJSONQueryParams struct {
	ParamName2 *string ` + "`json:\"param_name2\" validate:\"required\"`" + `
}
type PostExampleParamNameJSONHeaders struct {
	XHeader *string ` + "`json:\"X-Header\" validate:\"required\"`" + `
}
type PostExampleParamNameJSONRequestBody struct {
	Code *string ` + "`json:\"code\" validate:\"required\"`" + `
}
type PostExampleParamNameJSONRequest struct {
	Path    PostExampleParamNameJSONPathParams
	Query   PostExampleParamNameJSONQueryParams
	Headers PostExampleParamNameJSONHeaders
	Body    PostExampleParamNameJSONRequestBody
}
type PostExampleParamNameJSONResponse200Headers struct {
	XHeader *string ` + "`json:\"X-Header\" validate:\"required\"`" + `
}
type PostExampleParamNameJSONResponse200 struct {
	Headers *PostExampleParamNameJSONResponse200Headers
}
type PostExampleParamNameJSONResponse struct {
	StatusCode  int
	Response200 *PostExampleParamNameJSONResponse200
}
`,
			expectedHandlers: `// Code generated by github.com/jolfzverb/codegen; DO NOT EDIT.

package packagename

import (
	"context"
	"encoding/json"
	"net/http"
	"github.com/go-chi/chi/v5"
	"github.com/go-faster/errors"
	"github.com/go-playground/validator/v10"
	"imports/models"
)

type GetExample2JSONHandler interface {
	HandleGetExample2JSON(ctx context.Context, r *models.GetExample2JSONRequest) (*models.GetExample2JSONResponse, error)
}
type PostExampleParamNameJSONHandler interface {
	HandlePostExampleParamNameJSON(ctx context.Context, r *models.PostExampleParamNameJSONRequest) (*models.PostExampleParamNameJSONResponse, error)
}
type Handler struct {
	validator                *validator.Validate
	getExample2JSON          GetExample2JSONHandler
	postExampleParamNameJSON PostExampleParamNameJSONHandler
}

func NewHandler(getExample2JSON GetExample2JSONHandler, postExampleParamNameJSON PostExampleParamNameJSONHandler) *Handler {
	return &Handler{validator: validator.New(validator.WithRequiredStructEnabled()), getExample2JSON: getExample2JSON, postExampleParamNameJSON: postExampleParamNameJSON}
}
func (h *Handler) AddRoutes(router chi.Router) {
	router.Get("/example2", h.handleGetExample2)
	router.Post("/example/{param_name}", h.handlePostExampleParamName)
}
func (h *Handler) parseGetExample2JSONRequest(r *http.Request) (*models.GetExample2JSONRequest, error) {
	return &models.GetExample2JSONRequest{}, nil
}
func (h *Handler) writeGetExample2JSON200Response(w http.ResponseWriter, r *models.GetExample2JSONResponse200) {
}
func (h *Handler) writeGetExample2JSONResponse(w http.ResponseWriter, response *models.GetExample2JSONResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writeGetExample2JSON200Response(w, response.Response200)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handleGetExample2JSON(w http.ResponseWriter, r *http.Request) {
	request, err := h.parseGetExample2JSONRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.getExample2JSON.HandleGetExample2JSON(ctx, request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writeGetExample2JSONResponse(w, response)
	return
}
func (h *Handler) handleGetExample2(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handleGetExample2JSON(w, r)
		return
	case "":
		h.handleGetExample2JSON(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
func (h *Handler) parsePostExampleParamNameJSONPathParams(r *http.Request) (*models.PostExampleParamNameJSONPathParams, error) {
	var pathParams models.PostExampleParamNameJSONPathParams
	paramName := chi.URLParam(r, "param_name")
	if paramName == "" {
		return nil, errors.New("param_name path param is required")
	}
	pathParams.ParamName = &paramName
	return &pathParams, nil
}
func (h *Handler) parsePostExampleParamNameJSONQueryParams(r *http.Request) (*models.PostExampleParamNameJSONQueryParams, error) {
	var queryParams models.PostExampleParamNameJSONQueryParams
	paramName2 := r.URL.Query().Get("param_name2")
	if paramName2 == "" {
		return nil, errors.New("param_name2 query param is required")
	}
	queryParams.ParamName2 = &paramName2
	return &queryParams, nil
}
func (h *Handler) parsePostExampleParamNameJSONHeaders(r *http.Request) (*models.PostExampleParamNameJSONHeaders, error) {
	var headers models.PostExampleParamNameJSONHeaders
	xHeader := r.Header.Get("X-Header")
	if xHeader == "" {
		return nil, errors.New("X-Header header is required")
	}
	headers.XHeader = &xHeader
	return &headers, nil
}
func (h *Handler) parsePostExampleParamNameJSONRequestBody(r *http.Request) (*models.PostExampleParamNameJSONRequestBody, error) {
	var body models.PostExampleParamNameJSONRequestBody
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		return nil, err
	}
	err = h.validator.Struct(body)
	if err != nil {
		return nil, err
	}
	return &body, nil
}
func (h *Handler) parsePostExampleParamNameJSONRequest(r *http.Request) (*models.PostExampleParamNameJSONRequest, error) {
	pathParams, err := h.parsePostExampleParamNameJSONPathParams(r)
	if err != nil {
		return nil, err
	}
	queryParams, err := h.parsePostExampleParamNameJSONQueryParams(r)
	if err != nil {
		return nil, err
	}
	headers, err := h.parsePostExampleParamNameJSONHeaders(r)
	if err != nil {
		return nil, err
	}
	body, err := h.parsePostExampleParamNameJSONRequestBody(r)
	if err != nil {
		return nil, err
	}
	return &models.PostExampleParamNameJSONRequest{Path: *pathParams, Query: *queryParams, Headers: *headers, Body: *body}, nil
}
func (h *Handler) writePostExampleParamNameJSON200Response(w http.ResponseWriter, r *models.PostExampleParamNameJSONResponse200) {
	var err error
	headersJSON, err := json.Marshal(r.Headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	var headers map[string]string
	err = json.Unmarshal(headersJSON, &headers)
	if err != nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	for key, value := range headers {
		w.Header().Set(key, value)
	}
}
func (h *Handler) writePostExampleParamNameJSONResponse(w http.ResponseWriter, response *models.PostExampleParamNameJSONResponse) {
	switch response.StatusCode {
	case 200:
		if response.Response200 == nil {
			http.Error(w, "InternalServerError", http.StatusInternalServerError)
			return
		}
		h.writePostExampleParamNameJSON200Response(w, response.Response200)
	}
	w.WriteHeader(response.StatusCode)
}
func (h *Handler) handlePostExampleParamNameJSON(w http.ResponseWriter, r *http.Request) {
	request, err := h.parsePostExampleParamNameJSONRequest(r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	ctx := r.Context()
	response, err := h.postExampleParamNameJSON.HandlePostExampleParamNameJSON(ctx, request)
	if err != nil || response == nil {
		http.Error(w, "InternalServerError", http.StatusInternalServerError)
		return
	}
	h.writePostExampleParamNameJSONResponse(w, response)
	return
}
func (h *Handler) handlePostExampleParamName(w http.ResponseWriter, r *http.Request) {
	switch r.Header.Get("Content-Type") {
	case "application/json":
		h.handlePostExampleParamNameJSON(w, r)
		return
	case "":
		h.handlePostExampleParamNameJSON(w, r)
		return
	default:
		http.Error(w, "Unsupported Content-Type", http.StatusUnsupportedMediaType)
		return
	}
}
`,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			outputModels := &bytes.Buffer{}
			outputHandlers := &bytes.Buffer{}

			err := generator.GenerateToIO(context.Background(), input, outputModels, outputHandlers, "imports", "packagename")

			assert.NoError(t, err)
			assert.Equal(t, tc.expectedModels, outputModels.String())
			assert.Equal(t, tc.expectedHandlers, outputHandlers.String())
		})
	}
}
